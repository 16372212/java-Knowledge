## java内存

### 线程私有内容

#### 程序计数器

用来取指，计数器的值代表下一条执行的指令的地址

### 虚拟机栈

每次方法调用的数据都是通过栈传递的

java栈中保存的内容是栈帧，每一次函数调用都会有对应的栈帧被压入java栈，每一个函数调用结束之后，都有一个栈帧被弹出来。

### 本地方法栈
为虚拟机使用到的native方法服务。

### 堆
程序员声明的对象。

### 方法区

存放被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 对象的创建

### 1. 类加载检查

    虚拟机遇到new指令时，检查这个指令的参数是否能在常量池中定位到这个类的符号引用。

    检查这个符号引用代表的类是否被加载过、解析、初始化。没有就执行类加载过程。

### 2. 分配内存

    分配内存（在类加载完之后就能确定需要多少内存）

    把一块确定大小的内存从Java堆中划分出来。
        
        分配方式：“指针碰撞”、“空闲列表”。

        指针碰撞：java堆中的内存规整：中间一个指针作为java堆的分界点。分配内存就是指针往空闲空间那边挪动一个对象大小相等的距离。

        空闲列表：java堆中的内存不规整：虚拟机维护一个列表记录哪些内存块是可以用的。每次分配后更新列表的记录。

#### 解决内存划分中的同步问题：

        1. 对内存分布进行同步处理
        2. 按照线程划分。预先给每个线程分配一小块内存，哪个线程涉及分配内存，就在哪个线程的TLAB中分配。


### 3. 初始化零值

分配的内存空间需要都初始化0值。这样不赋初始值就能使用。

### 4. 设置对象头
设置对象头

    例如，对象是哪个类的实例，如何找到类的元数据信息，对象的hash码，对象的GC分代年龄等信息。

### 5. 执行init方法

    执行程序员设定的init方法

## 判断对象是否死亡
垃圾回收前需要判断。

### 方法：

> 引用计数法：被引用的次数是否变为0（很难解决对象之间相互循环引用的问题）

> 可达性分析法：通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的 路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象


### 判断类是否可以被回收

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾回收

区域：

新生代：Eden, suvivor0, suvior1
老生代

对象一开始优先进入Eden中。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 *Young GC*

经过一次垃圾回收后，存活下来的被放到suvivor0, suvivor1中，并且年龄+1
年龄达到一定的预置（默认为15）。

另外，大对象先进入老年区（因为大对象的复制会消耗很多）

*Old GC*
如果统计信息说，young gen待晋升（要移动到old gen）的数据比old gen空间大，则会出发full GC

### 垃圾收集的算法（其中两个）

> 标记-清除算法: 当内存区域满了的时候，将依旧存活的对象做标记，删除所有没有标记的对象

> 标记-复制： 将内存分成大小相同的两块。每次只使用其中一块。当其中的一块满了的时候，将存活的变量复制到另一块内存中，删除之前的整个内存。

对于新生代，每次收集会死亡大量的对象，所以适合用标记-清除，对于老生代，变量占内存大，复制代价高，并且存活率高。所以适合用标记-清除