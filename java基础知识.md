
[借鉴自](https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=jvm-vs-jdk-vs-jre)

## java基本类型：
    boolean
    char
    long
    short
    int
    float
    double
    byte
所占存储空间大小不变

## java关键字

    abstract	class	extends	final	implements	interface	native
    new	static	strictfp	synchronized	transient	volatile	

### 1. abstract 声明抽象

abstract关键字可以修改类或方法。

abstract类：（为了被子类重写）可以扩展（增加子类），但*不能直接实例化*。abstract方法不在声明它的类中实现，但必须在某个子类中重写。采用 abstract方法的类本来就是抽象类，并且必须声明为abstract。

### 2. static

    2.1 static 修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态的成员变量；一个对象改了其他的对象也改了。 ‘类名.成员变量名’的方式来使用

    2.2 static修饰方法： 静态方法只能继承，不能重写。可以不生成实例，直接用类名来调用

不能在静态方法中访问非静态成员变量
可以在非静态方法中访问静态的成员变量。因为非静态变量在创建对象实例时才为变量分配内存和初始化变量值。

    2.3 static修饰代码块
    首先执行静态代码块，然后执行构造方法。静态代码块在类被加载的时候执行

    2.4 static修饰类：
    只能用来修饰内部类，被static所修饰的内部类可以用new关键字来直接创建一个实例，不需要先创建外部类实例。static内部类可以被其他类实例化和引用（即使它是顶级类）。

### 3. synchronized

#### string, stringBuffer, stringBuilder

string本身继承自private final, 所以不能被更改

stringBuffer对方法增加了同步锁or对调用的方法加了同步锁

stringBuilder没有对调用方法增加同步锁，所以非线程安全。


#### hashcode equals

hashcode:确定对象在hash表中的索引位置（将内存地址转化为整数后返回）

equals: 确定两个对象是否真的相等。如果equal，则hashcode也一定相等。如果hashcode相等，则不一定equals


#### hashmap， hashtable
1. 同步
hashmap是非同步的，线程不安全。没有同步代码时，无法让多个线程同时使用

而hashtable是同步的

2. null值
hashmap循序有一个null key, multiple null values, while hashtable can not have null key or value

> why hashtable does not have null: to store and retrieve objects, hashtable should have implement `hashCode` method and `equal` method, but null is not object.(hashmap is an improvement based on hashtable)

3. hashMap更常见

### ++i i++
i = 1
b = ++i; // b = 2, 先i自增，再复制给b
b = i++; // b = 1, 先复制给b, i再自增

## java范型
让类型参数化。参数一旦确定好(具体的类型确定后)，如果类似不匹配，编译器就不通过。


### 范型类：
```java
public class Test<T> {
	T field1;
}
Test<String> test1 = new Test<>();
```
### 范型接口
```
public interface Iterable<T> {
}
```
### 范型方法
```java
public <T> void testMethod(T t){
}
```
> 泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的, 只和自己的定义有关

### <?>：
Sub 是 Base 的子类，不代表 List<Sub>和 List<Base>有继承关系。

<?>提供了*只读*的功能，也就是它删减了增加具体类型元素的能力，只保留与具体类型无关的功能
因此个人认为，<?>提高了代码的可读性

### 类型擦除

> 类型擦除： Java 在编译期间，所有的泛型信息都会被擦掉. 这也让范型和之前的代码可以兼容了。
```java
List<String> l1 = new ArrayList<String>();
List<Integer> l2 = new ArrayList<Integer>();
		
System.out.println(l1.getClass() == l2.getClass());
// 正确答案是 true。都是List.Class
```
在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <T>则会被转译成普通的 Object 类型，如果指定了上限如 <T extends String>则类型参数就被替换成类型上限。

范型会带来一些局限：确定类型之后，如果类型不匹配，编译器就不通过。（例如add（integet）后又add(string)， 这编译器就不通过）。但是可以通过类型擦除绕过这个问题：

```java
List<Integer> list = new ArrayList<>();

list.add(12);
//这里直接添加会报错
list.add("a");
Class<? extends List> clazz = list.getClass();
Method add = clazz.getDeclaredMethod("add", Object.class);
//但是通过反射添加，是可以的
add.invoke(list, "kl");

System.out.println(list);

```
			
> 泛型类或者泛型方法中，不接受 8 种基本数据类型。需要使用*包装类*：Integer List<int> li = new ArrayList<>();	

### 常用的通配符为： T，E，K，V，？
？ 表示不确定的 java 类型
T (type) 表示具体的一个 java 类型
K V (key value) 分别代表 java 键值中的 Key Value
E (element) 代表 Element

## equals
String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

## java的方法

静态方法：可以不实例化。调用方法可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式
访问变量只能访问静态成员，不能访问实例成员。

一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样

## 容器相关：

### hashcode & equals:

- equals: 根据两个对象的地址值进行比较（比较引用是否相同）但是String是已经重写了equals,即equals比较的是值，==比较的是地址

- hashcode: 对与对象来说，是本地方法，根据值算出来的（hashmap中的key, or hashset中的对象）

>hashCode() returns an integer value, generated by a hashing algorithm.(根据地址hash出来的一个int 32 位的整型数字)


hashcode 相同-> 再查看equals，相同则相同，不相同则不相同。

### 重写hashcode和equals
为什么要同时重写hashcode和equals，不同时重写会出现哪些问题？

要求相同的对象要保持相同的hashcode

如果只重写equals, 则new出来两个相同的对象，equals判断是客观相等，两个所有属性都相等的对象，但是地址不同。但是由于地址不同，hashcode返回的值是false

导致的问题：例如hashMap 想push一个存在的key, 但是hashMap检测不出key存在，就会push成功 

### equals 和 ==

基本数据类型：比较的都是值

- equals比较的是地址，重写之后比较的是值
- == 比较的是地址

### hashmap的方法：

1. 得到hashmap的key的hashcode
2. 通过（n-1）& hash判断当前元素存放的位置。
3. 位置中若存在元素，则判断元素与要存入的hash & key是否相同，*相同就覆盖*，不相同就通过拉链法解决冲突

后来，当链表长度>8, 则将链表转为红黑树

### concurrentHashMap & hashMap & hashTable

相同点：concurrentHashMap & hashMap 底层数据结构： 对于java1.8. 采用的是数组+链表/红黑树。

不同点：线程安全不同：

concurrentHashMap: （使用分段锁，只锁住了需要被修改的部分）使用 Node数组+ 链表 + 红黑树 实现，并发使用synchronized 和CAS来操作。

hashTable: （读写数据的时候，对整个容器上锁）使用的是synchronized来保证线程安全。效率低，如果多个同时访问同步方法，会产生阻塞or轮询。

### TreeSet, TreeMap和LinkedHashMap

TreeSet底层是TreeMap实现的.

TreeMap可以保持key的有序。如果有比较器，就按照比较器的大小进行排序，否则就按照key的顺序。
底层实现：

    插入：首先按照二叉排序树进行插入，根据大小往左往右。然后根据红黑树的规则进行调整，左旋、右旋、着色。

LinkedHashMap是有序的，按照插入顺序进行排序。

### 其他的树的结构和优缺点

二叉排序树：比如红黑树属于二叉排序树

（平衡二叉树）AVL: 左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

堆：左右两个节点都小于根结点。

最优二叉树：从根结点到各个内结点的加权路径长度之和最小的二叉树




    