# 一面暴露的不足：
## docker linux的一些指令，以及指令的区别
## 徒手写java创建进程的代码，下次尝试写一些sql语句
## spring的原理相关的信息
## linux实现隔离为什么有的用户还是可以访问其他namespace空间下的内容？
## zookeeper是什么
## java加锁的方法
## java写一个生产者和消费者
## sortedLinkedList原理补充
## mq实现原理，socket函数select的缺陷，epoll模型
## 数据库的数据权限

## kernal和cpu
kernel: 负责系统管理，比如内存管理，屏蔽了对硬件的操作。
cpu: 硬件层面上的，处理各种指令，提供运算

## 系统调用

程序都是运行在用户态的。
用来使用系统态级别的子功能的入口。

## 文件存储

### inode

inode:index node, 维护文件的属性信息

文件数据存储在块里。另外还需要inode来存储文件的元信息：某个文件被分成了几块，每一块的地址，文件拥有者，创建时间，权限，大小等。

每个 inode都有一个号码，linux使用inode号码区分不同的文件

使用`stat a.txt`查看inode信息

### 目录

- /bin: 所有二进制可执行文件，常用命令
- /etc 系统管理和配置文件
- /home 存放所有用户文件的根目录，用户主目录的基点。
- /usr 系统应用程序
- /opt tomcat等安装在这里。额外安装的可选应用程序包一般在这里
- root 系统管理员住目录
- /sbin 二进制可执行文件，系统管理员使用的系统级别的管理命令和程序。ifconfig等
- /dev 用来存放设备文件
- /mnt 让用户临时挂载其他的文件系统
- /boot 系统引导时的各种文件

## linux基本命令

1. 增删改查
    
    `cp -r 目录名，目录拷贝的目标位置` -r代表递归: 如果给出的源文件是目录文件，则将复制目录下所有的子目录和文件。

    ls ll区别： ll == ls -l , ll是查看目录下所有目录和文件的详细信息。(例如权限等)

    more一页一页查看

    cat查看全部文件， cat filename.txt | more

2. 打包并压缩

    tar -zcvf [压缩后的文件名] [要打包压缩的文件]

    z: 调用gzip压缩命令进行压缩
    c: 打包文件
    v: 显示运行过程
    f: 显示文件名

    解压： tar [-xvf] 压缩文件 `tar -xvf test.tar.gz`
    x: 解压   

3. 开发和调试程序
    
    netstat 显示网络相关的信息，如网络连接，路由表(-r)，接口状态
-a (all) 显示全部信息

    tcpdump 对网络上的数据包进行截获的包分析工具。

    ipcs提供进程间通信方式的信息，包括共享内存，信号量，消息队列。
    -a 输出所有
    -m 共享内存
    -q 消息队列
    -s 信号

    ipcrm 移除一个消息对象、或者共享内存、或者信号量

4. 文本处理 
    
    grep 文档详细查找

## linux中的权限：

    r: 可读。可以使用cat查看文件的内容
    w: 可写。可以修改文件的内容
    x: 可执行。可将其运行为二进制文件。

1. 查看所有者： `ls -ahl`, 修改所有者：chown 用户名
2. 查看文件所在组：`ls -ahl`, 修改所有者：chgrp 组名
3. 其他组：除了这个文件的所有者和所在组的用户外，其他所有用户都属于这个
4. 修改权限 `chmod`

## linux用户管理

多用户多任务的分时操作系统。

### 为什么用户之间可以共享文件

### shell

Shell是用户与Linux系统之间的接口.用户登录后，要启动一个进程，负责将用户的操作传给内核. 这个进程是用户登陆到系统以后运行的命令解释器。就是shell.

利用这一特点，我们可以限制用户只能运行指定的应用程序

## 其他命令

### 常用命令：

    1. grep 要搜索的字符串 要搜索的文件 --color（color表示高亮）
    grep 更适合单纯的查找或匹配文本，sed 更适合编辑匹配到的文本，awk 更适合格式化文本，对文本进行较复杂格式处理

    2. ps -ef/ ps -aux 查看当前系统正在运行进程。展示格式不同. ps aux|grep redis查看包括redis字符串的进程

    nethogs 查看某个进程占用的流量

>linux中进程的几个状态: 
- Z 僵尸
- S 休眠
- D 不可中断的休眠
- R 运行
- T 停止时跟踪

    3. kill -9 进程的pid : 杀死进程（-9表示强制终止）
        disown -r 将所有正在运行的进程移除

    4. 查看后台任务：job -l

    5. 把后台任务调到前台：fg

    6. 把停下来的后台任务在后台执行bg， 调整到前台执行：fg

    7. kill [-s <信息编号>] [程序] 或者 [-l <信息编号>]
        kill -9 pid
    
    8. 查看系统支持的所有信号： kill -l

    9. dirs 查看当前目录栈

    10. wc 文件多少行多少个字

    11. hash 执行过的命令的完整路径，打印所用过的命令以及执行的次数

    12. let 可以进行整数型的数学运算


### 网络通信命令

    查看当前系统的网卡信息：ifconfig

    查看与某台机器的连接情况：ping

    查看当前系统的端口使用： netstat -an

    shutdown -h now: 现在关机

    reboot -w: 重开机

## 常见的内存管理机制

- 块式管理：将内存固定的分成几个块，每个块只包含一个进程。
- 页式管理：将内存分成一页一页的格式，每页大小固定。页比较小。出发点是更好满足内存管理的需求。
- 段式管理：按照程序员设定的逻辑分段。每段大小是不同的。每段内部是连续的，之间是不连续的。
- 段页式：把主存先分成若干段，每段再分页。

虚拟地址到物理地址的转换是个问题。需要解决虚拟地址空间大，所以页表也会很大。

块表是什么： 分页管理中，页表的一部分，存放的是虚拟地址到物理地址的转换。存储在cache里，加速虚拟地址到物理地址的转换。

多级页表：避免所有的页表都放到内存中占地方太大。时间换空间。


## 共享内存

### 建立软连接和硬链接（文件共享）

#### 1. 硬连接：
（基于索引结点的文件共享方式）。每个文件有一个索引节点，inode中存在一个链接计数count。加入当用户B想要共享这个文件，那么用户B的目录中会增加一个目录项，并设置一个指针来指向该文件的索引结点。链接计数+1.

当B不想访问时，只能将count数目-1，count数目不是0的时候不能删除该文件。

    ln link source

#### 2. 软连接：
（利用符号链的共享方式）。比如让用户B共享A的一个文件F，系统会创建一个link类型的新文件取名为F. 将文件F写到用户B的目录里。这个文件F里，包括里B中F文件的路径。只有文件所有者才有指向索引结点的指针。这样不会留下悬空指针的问题。于是拥有者可以删除文件。这时候其他用户根据符号链再去访问时会发生访问失败，于是将符号链删除。（这个路径包括文件所在机器的网络地址和该机器中的文件路径。涉及多次读盘）

    ln -s slink source

### 内存共享的实现原理

一件是在内存划出一块区域来作为共享区；另一件是把这个区域映射到参与通信的各个进程空间。

>1. 内存映射：通过系统调用mmap()把这个文件所占用的内存空间映射到参与通信的各个进程地址空间，则这些进程就都可以看到这个共享区域，进而实现进程间的通信。

查看共享内存: ipcs -m

删除共享内存，使用命令：ipcrm -m [shmid]

### 共享内存什么时候会释放

### 用户为什么可以访问其他用户的空间

linux的容器：
namespace/cgroup对系统资源做了一层抽象，让系统资源对进程部分可见，在同一个namespace中的进程，可看到系统资源是一样的。




### 共享内存映射到进程空间后，存在进程的什么位置

### 共享内存段最大的限制

### 堆栈存储

### makefile编写

### 多线程和多进程的区别

### 常见的信号，系统如何将信号通知到进程

### i++是否是原子操作，为什么

### linux系统的各类同步机制

### linux系统各类异步机制


## cpu寻址

### 虚拟内存是什么

1. 使用硬盘空间扩充内存：访问的信息不在内存时，os将需要的部分调入内存。将不需要的还出。这样系统就为用户维护了一个大得多的存储器，就是虚拟存储器。虚拟存储器的大小由计算机的地址结构决定。

2. 定义了一个连续的虚拟地址空间。让每个进程都拥有一片完成的内存空间。

### 逻辑地址、虚拟地址、物理地址

逻辑地址：由程序产生的与段相关的偏移地址部分。比如指针的值就是逻辑地址 。机器语言指令中用来指定一个操作数或一条指令的地址

物理地址：实际的地址

虚拟地址：由计算机的地址结构决定。系统中的每个进程所使用的地址。比内存空间大很多。具体访问到哪个物理地址要看MMU将线性地址转换后的物理地址才能知道。

### 虚拟内存的技术实现

内存管理需要是离散的：请求分页，请求分段，请求段页式存储。

页面置换算法：

    缺页中断：需要访问的页没在内存。

    最佳页面置换算法：以后不怎么用的（无法实现
    FIFO页面置换算法
    LRU: 最近最久未使用页面置换算法（双链表和hashmap，hashmap的value存放链表指针，每次操作将对应的双链表中的值放到双链表的末尾) 
    LFU: 最少使用页面置换算法


## linux中的锁

1. 原子操作

    避免操作被进程/线程的调度打断。不会出现上下文切换

    实现方式：指令执行期间，给总线加锁（x86）

2. 自旋锁spinlock
    
    使用者想用临界区资源时，如果已经加锁，则不会阻塞，而是原地轮训资源判断是否释放锁。不会出现上下文切换。

    调用线程不会阻塞，但是轮训访问消耗cpu

    实现方式：CAS: compare and switch

        - While( CAS(value1, value2, value3 )) // 轮训访问，直到value1 == value2 时候，将value3赋值该value1

    使用场景：预计线程持有时间短。则互斥锁两次上下文切换的开销 > 自旋锁消耗的cpu
            代码经常需要加锁，但是实际情况产生竞争的情况比较少。

3. 互斥锁

    