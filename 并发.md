## 举例说明线程和进程

在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，main函数再的线程就是进程的主线程

## 多线程带来的问题

内存泄露、死锁、线程不安全

## 死锁：

条件：互斥、资源不可剥夺、请求并保持（一次性申请完所有资源）、循环等待（按照什么顺序申请资源，就按照什么顺序释放资源）

## sleep(), wait()方法的区别
sleep(): 没有释放锁

wait():释放了锁

    wait经常用于线程之间的交互、通信。调用之后，线程不会自动苏醒，需要别的线程调用notify()
    
    sleep通常用于暂停执行。调用之后，线程会自动苏醒。


## 通信方式

线程共享进程的*堆*和*方法区资源*。
但每个线程有自己的*程序计数器*、*虚拟机栈*和*本地方法栈*


- 堆：存放新创建的对象

- 方法区：已被加载的类信息，常量、静态变量、即时编译器编译后的代码 

- 虚拟机栈：为虚拟机执行java方法而服务，存放局部变量表、操作数栈、常量池等信息

- 本地方法栈：为虚拟机使用到的native方法服务。

进程通信：

    - socket通信（基于tcp/udp的通信方式，不同主机之间通过网络进行通信）
    - 信号量：用在解决进程之间的同步。
    - 消息队列：存放在内核里，只有内核重启（操作系统重启）或者显示地删除消息队列时，消息队列才被真正的删除
    - 共享内存：依赖互斥锁和信号量等等。
    - 管道(具有亲缘关系的父子进程间or兄弟进程之间的通信)

线程间通信：

    -互斥锁，读写锁：mutex, 比如java中的synchronized关键词和各种lock
    -信号量:
    -事件Event: Wait/Notify: 通过通知操作的方式保持多线程同步。方便的实现多线程优先级的比较操作。


## 线程池


线程池：使用池化思想管理线程的工具，主要解决资源分配的问题。

### 作用：（接受很多小任务并分发处理）很多小任务让一组线程来执行，而不是来一个任务就用一个线程。

内部维护若干线程。无任务时，这些任务都等待，有任务来到时，可以分配一个空闲线程来执行。如果所有的线程都忙碌，则放入等待队列或者增加一个新线程来处理。

### Runnable, callable区别

Runnable ：不会返回结果或抛出检查异常。不需要结果返回或者抛出异常检查的用Runnable

Callable：可以返回结果或抛出检查异常

### Execute, submit()

Execute()提交不需要返回的任务。无法判断任务是否被线程池执行成功与否

Submit（)会返回一个Future类型的对象。通过Future对象判断任务是否成功执行。且Future的get方法会获取返回值。get（）会阻塞当前线程直到任务完成。get内部可以设置超时时间。

### 创造方法：
使用ThreadPoolExecutor的构造函数，自定义参数来创建线程池。
```java

ThreadPoolExcuter executer = new ThreadPoolExecuter(
    CORE_POOL_SIZE,
    MAX_POOL_SIZE,
    KEEP_ALIVE_TIME,
    TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(QUEUE_CAPACITY),
    new ThreadPoolExecuter.CallerRunsPolicy());
```

### ThreadPoolExcuter important parametors:

    1. corePoolSize:最多可以同时运行的线程数目

    2. maximumPoolSize:线程池最大接受任务数目。 >这个值，说明不仅线程池内阻塞队列满了，还需要根据拒绝策略来处理该任务。默认的处理方法是直接抛异常。如果<这个值，且阻塞队列满了，则需要添加工程线程并执行。
    
    3. workQueue (BlockingQueue<Runnable>): 新任务来的时候判断当前运行线程数目量是否>corePoolSize并且<maximumPoolSize。满足就放到这个对列里。

### 其他参数：

    1.keepAliveTime: 线程最大等待时间，超时了就被销毁
    2.handler:饱和策略： >maximumPoolSize, 默认会抛出异常


