## 举例说明线程和进程

在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，main函数再的线程就是进程的主线程

## 多线程带来的问题

内存泄露、死锁、线程不安全

## 死锁：

条件：不剥夺、资源不可剥夺、请求并保持（一次性申请完所有资源）、循环等待（按照什么顺序申请资源，就按照什么顺序释放资源）

## sleep(), wait()方法的区别
sleep(): 没有释放锁

wait():释放了锁

    wait经常用于线程之间的交互、通信。调用之后，线程不会自动苏醒，需要别的线程调用notify()
    
    sleep通常用于暂停执行。调用之后，线程会自动苏醒。


## 通信方式

线程共享进程的*堆*和*方法区资源*。
但每个线程有自己的*程序计数器*、*虚拟机栈*和*本地方法栈*


- 堆：存放新创建的对象

- 方法区：已被加载的类信息，常量、静态变量、即时编译器编译后的代码 

- 虚拟机栈：为虚拟机执行java方法而服务，存放局部变量表、操作数栈、常量池等信息

- 本地方法栈：为虚拟机使用到的native方法服务。

## 线程池

线程池：使用池化思想管理线程的工具，主要解决资源分配的问题。

### 作用：（接受很多小任务并分发处理）很多小任务让一组线程来执行，而不是来一个任务就用一个线程。

内部维护若干线程。无任务时，这些任务都等待，有任务来到时，可以分配一个空闲线程来执行。如果所有的线程都忙碌，则放入等待队列或者增加一个新线程来处理。

### 创造方法：
使用ThreadPoolExecutor的构造函数，自定义参数来创建线程池。
```java

ThreadPoolExcuter executer = new ThreadPoolExecuter(
    CORE_POOL_SIZE,
    MAX_POOL_SIZE,
    KEEP_ALIVE_TIME,
    TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(QUEUE_CAPACITY),
    new ThreadPoolExecuter.CallerRunsPolicy());
```

### ThreadPoolExcuter important parametors:

    1. corePoolSize:最多可以同时运行的线程数目

    2. maximumPoolSize:线程池最大接受任务数目。 >这个值，说明不仅线程池内阻塞队列满了，还需要根据拒绝策略来处理该任务。默认的处理方法是直接抛异常。如果<这个值，且阻塞队列满了，则需要添加工程线程并执行。
    
    3. workQueue (BlockingQueue<Runnable>): 新任务来的时候判断当前运行线程数目量是否>corePoolSize并且<maximumPoolSize。满足就放到这个对列里。

### 其他参数：

    1.keepAliveTime: 线程最大等待时间，超时了就被销毁
    2.handler:饱和策略： >maximumPoolSize, 默认会抛出异常


