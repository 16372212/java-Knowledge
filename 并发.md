# 知识脉络

## 线程安全的实现方法: 
- 互斥同步: synchronized 和 ReentrantLock 
- 非阻塞同步: CAS, AtomicXXXX 
- 无同步方案: 栈封闭，Thread Local，可重入代码

## 并发问题的根源：保证线程安全的三要素

1. *可见性*：CPU缓存引起
一个线程对共享变量的修改，另一个线程能立即看见。

现象：一个线程1修改一个变量，会先把变量放到cpu缓存中，但这时，另一个线程（对应的cpu不相同！so 缓存不同）需要读取这个变量，从内存中读取出来的结果不一样。


> 解决方案：1 JMM（java内存模型）提供来volatile 2 synchronized，lock

    volatile: 当一个共享变量被volatile修饰时，保证修改的值立即被更新到主存。

    synchronized, lock的方法：锁释放前，进程会将对变量的修改更新到主存。

2. *有序性*：重排序引起
程序执行的顺序按照代码的先后顺序执行。（允许jvm对指令重新排序）

> 解决方案：as-if-seria（线程内）：指令重排序，但不会对存在数据以来的操作重新排序，保证排序后结果不变。
> happends-before（多线程）
> volatile， synchronized, lock都可以用来保证有序性。


3. *原子性*：分时复用引起
一个操作要么都完成，要么都不完成。现在只有基本的读取和赋值是原子操作，因此需要结合锁。

> 方案：悲观锁：synchronized关键字，jvm级别锁。
> 乐观锁：自旋锁+CAS。无法保证可见性，一般配合volatile使用。

## JMM java内存模型
本质：规范了JVM如何按需禁用缓存 和 如何编译优化

> 方法：volatile, synchronized, final ； happends-before规则。

### volatile, synchronized, final， lock

#### volatile

使用条件：
- 只有状态独立与程序内其他内容才能使用volatile.
- 变量没有包含在具有其他变量的不变式中。
- 状态独立于程序内其他内容


1. volatile实现可见性

> 基于内存屏障实现的

    添加了vilatile关键字的变量，在修改时，jvm产生一个lock前缀的指令发送给该cpu1，这个指令会将当前处理器缓存行的数据写回到内存。内存被写会后，其他的处理器中的缓存也会失效，因此会从内存中重新读取新的数据。(缓存一致性协议：处理器在总线上传播的数据检查自己的缓存是否过期，过期则回重新从内存读取新的数据)，

    lock前缀的指令：锁定的是缓存。

2. volatile实现有序

> 基于 happens-before实现

    happens-before规则：对volatile变量的写必须 发生在 任意后续中对volatile变量的读。
    （提供一个内存屏障）

> volatile禁止重排的方法: StoreStore, StoreLoad, LoadLoad, LoadStore

- volatile写操作：前面有一个StoreStore防止上面的写操作和下面的volatile写重新排序。后面有一个StoreLoad：防止后面的写操作和上面的volatile写重排序

- volatile读操作：后面有一个LoadLoad防止后面的读和上面的volatile读重排序。后面还有一个LoadStore防止后面的写和上面的volatile读重排序


3. volatile不能实现原子性

#### synchronized

tips: 方法正常执行or抛出异常，都会释放锁

synchronized对象：方法锁 and 类锁

方法锁：
- 对于普通同步方法，锁是当前实例对象。（每个实例都对应有自己的一把锁(this),不同实例之间互不影响
- 方法块：synchronized括号里配置的对象

类锁：
- 静态方法 or *.class：锁是当前class，class的所有对象通用一个锁



##### *1 使用方法*

- this方法 或者 手动指定锁
```java
// this方法
public void run(){
    // 代码块同步  this, 两个线程运行run，使用的同一个锁，线程1等待0完成后再执行
    synchronized(this){
        try{
            Thread.sleep(3000);
        }catch(InterruptedException e){
            e.printStackTrace();
        }
    }
}

Thread t1 = new Thread(instence); // instence是上文中声明的构造器
Thread t2 = new Thread(instence);
t1.start();
t2.start();

// 手动设置锁
Object block1 = new Object();
Object block2 = new Object();

public void run(){
    synchronized(block1){

    }
    synchronized(block2){

    }
}

public static void main(String[] args){
    Thread t1 = new Thread(instence);
    Thread t2 = new Thread(instence);
    t1.start();
    t2.start();
}
```

当两个thread分别传入不同的instence时候：
`Thread t1 = new Thread(instence1);`以及`Thread t1 = new Thread(instence2);`

锁用在普通方法，默认锁就是this，无法实现锁的功能（因为是两个锁）；修饰静态方法，默认的锁就是当前在的Class类，这就是一个锁，才能实现不同进程中这个方法的同步。
```java
public void run(){
    method();
}
public synchronized void method(){

}
public void run(){
    method();
}
```

##### *2 synchronized原理*

保持monitor计数器。某个对象在一个时间内与一个monitor关联。一个monitor在同一时间只能被一个线程获得。
当一个对象尝试获得monitor时，会执行`monitorenter`:当monitor计数器为0，说明没有人获得锁，线程就会申请得到锁，然后将计数器+1。每当有新进程想要获得锁，计数器就加1。释放则-1

monitorexit指令：释放对于monitor的所有权，monitor的计数器减1.

> Monitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1

> 可重入原理：加锁次数计数器.p无v

1. synchronized实现可见性的原理：

```java
public class MonitorDemo{
    public synchronized void writer(){

    }
    public synchronized void reader(){

    }
}
```
##### *3 synchronized的存储位置*

锁的信息：存放在Java对象头中Mark Word中。（存储hashCode, 锁标记位，分代年龄）


##### *4 synchronized的优化*

- 锁粗化(Lock Coarsening，减少不必要的紧连在一起的unlock，lock操作)、
- 锁消除(Lock Elimination)、
- 轻量级锁(Lightweight Locking)：无锁竞争的情况下避免调用mutex这种重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态。
- 使用偏向锁(Biased Locking，无竞争时避免CAS)
- 适应性自旋(Adaptive Spinning)：CAS失败时，不立即调用与monitor相关联的mutex semaphore, 而进入忙等待(Spinning)然后再次尝试。当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。


##### **5. 锁的类型**
1. 偏向锁

> 偏向锁中，mark word存储线程id, epoch, 年龄

解决的问题：大部分锁不存在多线程竞争，而是一个线程多次获得锁。

请求方法：线程访问同步块获得锁时，将对象头和栈帧中的锁记录里存储的偏向锁的线程ID。以后线程在进入和推出同步块时，不需要CAS加锁解锁，只用看java对象头的mark word里面是否存储当前线程的偏向锁。如果存储，则说明已经获得锁了。

如果没有，且当前mark word中如果偏向锁的标识为1（当时是偏向锁），是就尝试用CAS将对象头的偏向锁指向当前进程。CAS成功，就获得锁资源，失败就产生竞争，触发偏向锁的撤销：


撤销方法：
竞争出现才释放锁。需要等待当前进程的全局安全点：没有正在执行的字节码。

进程撤销会暂停当前mark word指向的线程。暂停后判断该线程是否活着，如果不活动了（退出同步代码块），则将对象头设置为无锁状态，最后恢复这个线程。如果线程还活着，没有退出同步代码块，则升级为轻量级锁。 

偏向锁可以通过JVM参数关闭：-XX: -UseBiasedLocking=false

2. 轻量级

> 轻量级锁中，mark word存储指向栈中锁记录的指针

加锁：首先将mark word复制到锁记录里。叫做displaced mark word. 然后将线程尝试使用CAS将对象头中的mark word中锁记录的指针替换。成功则获得锁。失败则使用自旋获取。

解锁：使用原始的CAS将displaced mark word换回成对象头。失败，则说明存在竞争，锁膨胀成为重量级锁。


##### 使用的注意事项

- 锁对象不能为空，因为锁的信息都保存在对象头里 
- 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错 
- 避免死锁
- 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错

#### final

final修饰方法，可以被重载。
static final: 定义时必须赋值，不然编译器不通过。但是没有static, 则说明每次实例化之后才加载赋值，在使用前赋值即可。

并发时的重排序
    
    写final域重排序（保证final域被正确初始化）：禁止 “对final域进行写” 排序到 构造函数之外。JMM禁止编译器把final域的写重排序到构造函数之外。会在写之后，构造函数return之前插入一个storestore屏障。保证对象对所有线程可见之前，对象的final域已经全初始化了。

    读final域冲排序：初次读对象引用和 读final域 不会重排序，保证先读取对象引用，再读final域。方法是读final域前有一个LoadLoad屏障。

final的一些限制条件

- 构造函数退出之前必须对final域赋值
- final修饰指向对象，只能让**引用**设为不可变，例如`private final List mylist = new ArrayList()`，而不是所指的对象。所以，mylist依然可以执行.add
- 一个对象将在多个线程中访问，并且没有将成员声明为final，则必须提供其他方式保证线程安全，例如volatile， synchronized, or lock.

#### lock

lock(): 加锁
unlock(): 解锁
tryLock(): 尝试获取锁，返回一个boolean值
tryLock(long,TimeUtil): 尝试获取锁，可以设置超时

##### 和synchronized区别

1. 释放锁时间不同：synchronized在异常or结束才能释放. 但是lock可以设置中断和超时
2. 是否通知锁的状态：synchronized不知道是否拿到锁，lock可以获得状态。
3. lock必须有一个unlock来释放锁。

#### 原子操作

CAS自旋 + 锁

锁：偏向锁、轻量级锁、互斥锁。除了偏向锁，都是用来循环CAS. 线程想进入同步块时使用循环CAS获得锁，退出同步块使用循环CAS释放锁。


# 一些问题
## 举例说明线程和进程

在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，main函数再的线程就是进程的主线程

## 多线程带来的问题

内存泄露、死锁、线程不安全

## 死锁：

条件：互斥、资源不可剥夺、请求并保持（一次性申请完所有资源）、循环等待（按照什么顺序申请资源，就按照什么顺序释放资源）

## sleep(), wait()方法的区别
sleep(): 没有释放锁

wait():释放了锁

    wait经常用于线程之间的交互、通信。调用之后，线程不会自动苏醒，需要别的线程调用notify()
    
    sleep通常用于暂停执行。调用之后，线程会自动苏醒。


## 通信方式

线程共享进程的*堆*和*方法区资源*。
但每个线程有自己的*程序计数器*、*虚拟机栈*和*本地方法栈*


- 堆：存放新创建的对象

- 方法区：已被加载的类信息，常量、静态变量、即时编译器编译后的代码 

- 虚拟机栈：为虚拟机执行java方法而服务，存放局部变量表、操作数栈、常量池等信息

- 本地方法栈：为虚拟机使用到的native方法服务。

进程通信：

    - socket通信（基于tcp/udp的通信方式，不同主机之间通过网络进行通信）
    - 信号量：用在解决进程之间的同步。
    - 消息队列：存放在内核里，只有内核重启（操作系统重启）或者显示地删除消息队列时，消息队列才被真正的删除
    - 共享内存：依赖互斥锁和信号量等等。
    - 管道(具有亲缘关系的父子进程间or兄弟进程之间的通信)

线程间通信：

    -互斥锁，读写锁：mutex, 比如java中的synchronized关键词和各种lock
    -信号量:
    -事件Event: Wait/Notify: 通过通知操作的方式保持多线程同步。方便的实现多线程优先级的比较操作。


## 参考文献

[参考文章](https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html)
《深入理解Java虚拟机》
《Java并发编程的艺术》