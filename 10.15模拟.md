对背八股文的反馈：说出思想就好，不要太追根究底

# 基础

## 1. hashMap:

1. 转红黑树：链表长度超过8，整体长度超过64

2. 扩容：数量超过阈值

3. 为什么是0.75:时间和空间互换。太低：耗费性能，太高hash冲突会增多。

4. 双亲委派

一级一级往上找。

每个类加载器都有一个父加载器。 当需要加载类时，会优先委派当前所在的类的加载器的父加载器去加载这个类。 如果父加载器无法加载到这个类时，再尝试在当前所在的类的加载器中加载这个类。

# 多线程

线程池的执行策略。

线程池怎么实现的

拒绝策略（一共四种）

    1. abortPolicy 丢弃并抛出一场

    2. discardPolicy 丢弃任务，不抛出异常

    3. discardOldestPolicy 丢弃任务队列中最前面的异常

    4. CallerRuns 提交任务的线程直接执行这个任务。

    线程池的使用方法：

```java

// 一类是通过Executors工厂类提供的方法，该类提供了4种不同的线程池可供使用。另一类是通过ThreadPoolExecutor类进行自定义创建。

newCachedThreadPool
newFixedThreadPool // 固定大小的线程池。可控制并发的线程数，超出的线程会在队列中等待。
newScheduledThreadPool // 定时及周期性执行任务。
newSingleThreadExecutor // 创建一个单线程的线程池

private ExecutorService pool; // pool定义

pool.submit()

```

（1）corePoolSize：核心线程数，线程池中始终存活的线程数。

（2）maximumPoolSize: 最大线程数，线程池中允许的最大线程数。

（3）keepAliveTime: 存活时间，线程没有任务执行时最多保持多久时间会终止。

（4）unit: 单位，参数keepAliveTime的时间单位，7种可选。

（5）workQueue: 一个阻塞队列，用来存储等待执行的任务，均为线程安全，7种可选。

（6）threadFactory: 线程工厂，主要用来创建线程，默及正常优先级、非守护线程。

（7）handler：拒绝策略，拒绝处理任务时的策略，4种可选，默认为AbortPolicy。


# 锁

# Synchronized

1. 锁的升级过程：无锁、偏向锁、轻量级、重量级锁

        1. 无锁。
        2. 【首次执行】synchronized代码块时，变成偏向锁。偏向锁：偏向于第一个获取它的线程。同步块执行后，不主动释放偏向锁。
        3. 轻量级锁。一旦出现【锁竞争】，升级为轻量级锁。锁的标志位为释放，则CAS操作修改锁的标志位，并释放锁。如果锁的标志位为锁定，则【自旋】等待锁的释放。
        4. 【自旋次数】超过阈值，则通过CAS修改锁的标志位，表示升级为重量级锁

2. 底层实现

        Sychronized 是【JVM】层面的关键字。它是通过 【字节码指令】实现的。
            
        (1) Sychronized 修饰 【代码块】时，montior-enter monitor-exit两个字节码指令表明 同步块的开始和结束位置。monitorenter尝试获取对象所对应的 Monitor 所有权。

        (2) Sychronized 修饰 【方法】时，JVM中通过ACC_SYCHRONIZED 标志同步方法

## lock：

    lock重要的方法

lock(): 加锁
unlock(): 解锁
tryLock(): 尝试获取锁，非阻塞获得，返回一个boolean值
tryLock(long,TimeUtil): 尝试获取锁，可以设置超时。

### ReentrantLock
是通过AQS(AbstractQueuedSynchronizer)的来实现线程调度。


先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：

非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；
公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁


- 公平锁/非公平锁. 

实现了lock接口。
方法：

- nonfairTryAcquire方法
- tryAcquire
- tryRelease
- tryLock

> ReentrantLock是可重入锁

## AQS的一些重要方法

AQS队列同步器。用来构建锁和其他同步组建。CLH: 虚拟的双向队列。把每条请求共享资源失败（获取同步状态state失败）线程封装成CLH的节点。

包含的数据结构：state同步状态，CLH阻塞队列的头节点和尾节点。

当 state > 0 时，表示已经获取了锁。
当 state = 0 时，表示释放了锁。

方法
- `getState`, 
- `setState` 
- `compareAndSetState`

需要重写的方法：
- `tryAcquire` : 独占获取同步状态，判断是否符合预期，
- `tryRelease`：独占获取释放状态，

# 可重入锁

支持在已经获得锁的线程中，再一次的去访问以这个对象为锁的同步块的时候，不需要再一次去获得锁，只需要增加 objectMonitor 中的重入次数（_recursions）就可以了

可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。

可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能


# 框架

## Spring的理解：
    
    1. 管理bean的容器。 支持AOP以及IOC。

bean的生命周期：解析（解析类，得到beanDefinition）构造（选择构造方法，利用构造方法实例化得到对象）属性填充（autowired注解的属性填充。）调用BeanAware方法，初始化, AOP, 使用bean, Spring容器关闭的时候调用destory方法


## AOP


动态代理: 无法直接访问对象，所以访问此对象时，在此对象上加一个对此对象的访问层。

代理：想要访问一个继承接口i的对象a，需要创建一个继承接口i的对象b, b中包含了对象a。通过对b进行对象a的控制。

动态代理：在运行期动态创建某个interface的实例。织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。

通知类型：？？？


## 事物的隔离级别
read uncommitted（未提交读）
read committed（提交读、不可重复读）
repeatable read（可重复读）
serializable（可串行化）


## 事物传播机制：Spring



## SpringMVC工作流程（具体名字也要背下来

handlerMapping: 根据url找到handler
handlerAdapter: 找到对应的Servlet处理方法来调用handler

1. 用户发送请求到前端控制器。

2. 收到请求，调用handlerMapping处理器映射器

3. 处理器映射器找到具体的处理器。HandlerAdapter

4. 前段控制器调用处理器适配器HandlerAdapter

5. HandlerAdapter调用处理器（controller)

6. controller执行完返回model and view

7. handlerAdapter将ModelAndView返回给前段控制器

8. ModelAndView被解析成view视图，然后经过渲染，返回


## 中间件

。。。是什么

redis: 
1. 数据类型5：应用场景。string(sds)set, hash（用户属性）, linklist（消息队列、关注列表）, zset（有优先级的set，排行榜）

2. 为啥快（内存，单线程，IO多路复用）

3. 持久化：

4. 删除策略：定期就是定时


5. 缓存雪崩，穿透，击穿。

6. 集群：主从+哨兵+ 集群
	哨兵的原理：（见图片）




实习经历


持久化（可靠）：
轻量级：（redis轻量级）

mq： 消息丢失，重复消费，持久化


一旦用到定时任务，不是单机的。定时任务用到分布式锁。（就一行代码）
	又会问到分布式锁的问题：业务还没执行，锁超时了怎么办：（看图片+加网上搜索

docker具体指的是什么。
