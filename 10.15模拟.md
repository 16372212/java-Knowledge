对背八股文的反馈：说出思想就好，不要太追根究底

# 基础

## 1. hashMap:

1. 转红黑树：链表长度超过8，整体长度超过64

2. 扩容：数量超过阈值

3. 为什么是0.75:时间和空间互换。太低：耗费性能，太高hash冲突会增多。

4. 双亲委派

一级一级往上找。

每个类加载器都有一个父加载器。 当需要加载类时，会优先委派当前所在的类的加载器的父加载器去加载这个类。 如果父加载器无法加载到这个类时，再尝试在当前所在的类的加载器中加载这个类。
    目的：防止用户自己编写的类动态替换核心类。以及重复加载。相同的class文件被不用的class loader加载就是不同的两个类。


1. 数据库的ACID，隔离级别以及隔离级别怎么实现的？


2.redis雪崩、击穿、穿透三个概念


3.常见http返回码

    2xx: 成功处理请求
        200: 服务器成功处理了请求并提供了请求的网页
    3xx: 重定向
        304: 网页自上次请求后，没更新（用户请求时可以放一个时间，返回304则不再需要重新解析网页）
    4xx: 客户端错误
        404: 服务器找不到请求的网页
    5xx: 服务器错误
        500: 服务器遇到错误，无法完成


4.浏览器输入URL到页面返回的一个过程


5. 内部类能不能访问外部类的私有成员。

    可以访问。
    原因：在编译器中，没有内部类和外部类之分，但是编译器会让内部类多一个【常量】，指向外部类。自动修改【内部类构造器】，初始化这个常量。
    外部类【扫描内部类调用】了外部类的哪些私有属性，调用了会为这个私有属性创造一个access$xxx 【静态方法】。这个方法返回私有属性对应的值。

    外部类可不可以访问？
    外部类想访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问. 可以用这几个词修饰内部类。public 都可以访问，private修饰时只能在外部类的内部访问，protected修饰只能在同一个包下或者继承外部类的情况下访问

6. 有哪些路由表算法

    1. 链路状态
        每个路由掌握全部拓扑结构信息。使用洪泛法，每次向所有路由信息发送 和自己相邻的路由信息。链路状态改变才发送。ospf：收敛快

    2. 距离向量
        周期性向相邻的路由发送自己掌握的所有可达信息：自己可以到达的网络以及相距距离。相邻路由器收到后根据这个修改自己的路由表。 过程慢，容易实现
    3. 

7. 如何不通过乘法，计算出两个数的乘积？
    一个左移一个右移

8. http报文格式，头部和请求体之间用什么隔开。http报文的结构，HTTP协议常用的请求方式？除了在url和消息体里面传参数，还有什么可以传参数的方式？

        报文首部和报文主体构成，中间由一个空行分隔


如果微服务的域很大，如何解决模块间相互通信的协议的问题？答：不会

java 运行时多态怎么实现的？


进程间通信方式：（场景适用）

多态的表现形式

图的遍历，使用什么数据结构

spring相关知识



# 多线程

线程池的执行策略。

线程池怎么实现的

拒绝策略（一共四种）

    1. abortPolicy 丢弃并抛出一场

    2. discardPolicy 丢弃任务，不抛出异常

    3. discardOldestPolicy 丢弃任务队列中最前面的异常

    4. CallerRuns 提交任务的线程直接执行这个任务。

    线程池的使用方法：

```java

// 一类是通过Executors工厂类提供的方法，该类提供了4种不同的线程池可供使用。另一类是通过ThreadPoolExecutor类进行自定义创建。

newCachedThreadPool
newFixedThreadPool // 固定大小的线程池。可控制并发的线程数，超出的线程会在队列中等待。
newScheduledThreadPool // 定时及周期性执行任务。
newSingleThreadExecutor // 创建一个单线程的线程池

private ExecutorService pool; // pool定义

pool.submit()

```

（1）corePoolSize：核心线程数，线程池中始终存活的线程数。

（2）maximumPoolSize: 最大线程数，线程池中允许的最大线程数。

（3）keepAliveTime: 存活时间，线程没有任务执行时最多保持多久时间会终止。

（4）unit: 单位，参数keepAliveTime的时间单位，7种可选。

（5）workQueue: 一个阻塞队列，用来存储等待执行的任务，均为线程安全，7种可选。

（6）threadFactory: 线程工厂，主要用来创建线程，默及正常优先级、非守护线程。

（7）handler：拒绝策略，拒绝处理任务时的策略，4种可选，默认为AbortPolicy。


# 锁

# Synchronized

1. 锁的升级过程：无锁、偏向锁、轻量级、重量级锁

        1. 无锁。
        2. 【首次执行】synchronized代码块时，变成偏向锁。偏向锁：偏向于第一个获取它的线程。同步块执行后，不主动释放偏向锁。
        3. 轻量级锁。一旦出现【锁竞争】，升级为轻量级锁。锁的标志位为释放，则CAS操作修改锁的标志位，并释放锁。如果锁的标志位为锁定，则【自旋】等待锁的释放。
        4. 【自旋次数】超过阈值，则通过CAS修改锁的标志位，表示升级为重量级锁

2. 底层实现

        Sychronized 是【JVM】层面的关键字。它是通过 【字节码指令】实现的。
            
        (1) Sychronized 修饰 【代码块】时，monitior-enter monitor-exit两个字节码指令表明 同步块的开始和结束位置。monitorenter尝试获取对象所对应的 Monitor 所有权。

        (2) Sychronized 修饰 【方法】时，JVM中通过ACC_SYCHRONIZED 标志同步方法

## lock：

    lock重要的方法

lock(): 加锁
unlock(): 解锁
tryLock(): 尝试获取锁，非阻塞获得，返回一个boolean值
tryLock(long,TimeUtil): 尝试获取锁，可以设置超时。

### ReentrantLock
是通过AQS(AbstractQueuedSynchronizer)的来实现线程调度。


先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：

非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；
公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁


- 公平锁/非公平锁. 

实现了lock接口。
方法：

- nonfairTryAcquire方法
- tryAcquire
- tryRelease
- tryLock

> ReentrantLock是可重入锁

## AQS的一些重要方法

AQS队列同步器。用来构建锁和其他同步组建。CLH: 虚拟的双向队列。把每条请求共享资源失败（获取同步状态state失败）线程封装成CLH的节点。

包含的数据结构：state同步状态，CLH阻塞队列的头节点和尾节点。

当 state > 0 时，表示已经获取了锁。
当 state = 0 时，表示释放了锁。

方法
- `getState`, 
- `setState` 
- `compareAndSetState`

需要重写的方法：
- `tryAcquire` : 独占获取同步状态，判断是否符合预期，
- `tryRelease`：独占获取释放状态，

# 可重入锁

支持在已经获得锁的线程中，再一次的去访问以这个对象为锁的同步块的时候，不需要再一次去获得锁，只需要增加 objectMonitor 中的重入次数（_recursions）就可以了

可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。

可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能


# 框架

## Spring的理解：
    
    1. 管理bean的容器。 支持AOP以及IOC。

bean的生命周期：解析（解析类，得到beanDefinition）构造（选择构造方法，利用构造方法实例化得到对象）属性填充（autowired注解的属性填充。）调用BeanAware方法，初始化, AOP, 使用bean, Spring容器关闭的时候调用destory方法


## AOP


动态代理: 无法直接访问对象，所以访问此对象时，在此对象上加一个对此对象的访问层。

代理：想要访问一个继承接口i的对象a，需要创建一个继承接口i的对象b, b中包含了对象a。通过对b进行对象a的控制。

动态代理：在运行期动态创建某个interface的实例。织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。

通知类型：？？？


## 事物的隔离级别
read uncommitted（未提交读）
read committed（提交读、不可重复读）
repeatable read（可重复读）
serializable（可串行化）


## 事物传播机制：Spring



## SpringMVC工作流程（具体名字也要背下来

handlerMapping: 根据url找到handler
handlerAdapter: 找到对应的Servlet处理方法来调用handler

1. 用户发送请求到前端控制器。

2. 收到请求，调用handlerMapping处理器映射器

3. 处理器映射器找到具体的处理器。HandlerAdapter

4. 前段控制器调用处理器适配器HandlerAdapter

5. HandlerAdapter调用处理器（controller)

6. controller执行完返回model and view

7. handlerAdapter将ModelAndView返回给前段控制器

8. ModelAndView被解析成view视图，然后经过渲染，返回


## 中间件

。。。是什么

redis: 
1. 数据类型5：应用场景。string(sds)set, hash（用户属性）, linklist（消息队列、关注列表）, zset（有优先级的set，排行榜）

2. 为啥快（内存，单线程，IO多路复用）

3. 持久化：

4. 删除策略：定期就是定时

5. 缓存雪崩，穿透，击穿。

6. 集群：主从+哨兵+ 集群
	哨兵的原理：（见图片）

哨兵每次向建立的链接发送ping命令。如果在多毫秒内没有做出响应，就标记为下线。当一个哨兵节点发现主节点下线，就向其他哨兵节点发出询问。如果超过n个节点任务主节点下线，将从节点升级为master, 并让失效的master变成从节点。

集群：

    1. 去中心化，客户端链接集群中的任意一个节点
    2. 所有的节点彼此互联
    3. 超过一定个数的节点失效即失效
    4. 自动将节点分成主从、主从复制。
    5. 内置16384个hash槽。

实习经历

持久化（可靠）：
轻量级：（redis轻量级）

mq： 
消息丢失
重复消费
持久化


一旦用到定时任务，不是单机的。定时任务用到分布式锁。（就一行代码）

    分布式锁: 基于redis实现：setnx设置并使用expire定义超时时间。spring中有面向redis提供的注入类。redistemplate是spring提供的简化redis操作的模版。

	又会问到分布式锁的问题：业务还没执行，锁超时了怎么办：（看图片+加网上搜索

    解决办法，
    1. 可以使用redisson。是一个对redis操作进行封装的客户端。redisson内部提供了一个监控锁的看门狗，为将要过期但是没执行完的锁，延长有效时间。
    2. 业务执行完毕后手动释放。
    3. 将超时的时间设置的足够长。

docker具体指的是什么。
