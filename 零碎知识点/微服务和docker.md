# 项目涉及到的基础知识

## 1 微服务
### 1.1 微服务是什么

1 将一个单体应用拆分成了一组微小的服务组件。这些组件以业务为中心
2 每个组件运行在自己的进程上。组件之间通过轻量级机制进行交互。
3 独立部署：使用自动化部署机制部署这些组件。
4 独立语言or数据库：采用不同的语言及存储

### 1.2 为什么使用微服务

伸缩性(scalable)

- 每个服务都可以在横向和纵向上扩展

X轴扩展：负载均衡后，运行多份拷贝，来分摊负载（每个拷贝运行1/n的负载）。

Y: 业务扩展：划分成了多个不同的服务，一个服务负责一个或者一部分的功能。

Z: 数据集的划分

- 每个服务都可按硬件资源的需求进行独立扩容

IO密集型模块和CPU密集型模块无法独立升级和扩容。业务模块对资源的需求不一样，由于所有模块部署到一起，单体架构IO密集型模块和CPU密集型模块无法独立升级和扩容的，比如图片压缩，加解密这些 都是cpu资源密集的应该升级CPU，而IO密集型的模块比如日志收集服务IO操作比较多需要更大的内存，使用比如SSD性能更好的磁盘。

#### 扩容的方式：api网关
服务集群暴露在公网的统一入口。

作用：

1. 统一对外接口：减少提供接口的差异。
2. 统一鉴权：不用每个应用单独对调用方进行鉴权，应用可专注于服务。
3. 服务注册和授权：用来控制调用方能使用和不能使用哪些服务。
4. 服务限流：限制调用房调用每个接口的每日次数
5. 全链路跟踪：方便通过api网关提供的请求ID来监控调用流程。

可靠性

- 一个bug有可能引起整个应用的崩溃
由于所有模块都是部署在一个实例中，一个bug会引起整个应用的崩溃，比如一个不重要的模块的内存泄露就将会导致所有应用实例一个个crash掉


### 1.3 微服务的优缺点

### 1.4 springcloud技术选型
1. springcloud的服务发现`eureka`：
`Eureka` 就是一个服务发现框架: 实现模块定位服务，从而进行负载均衡和中间层服务器的故障转移。
Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务
docker 

> 服务发现的业务流程：
- 服务注册：Eureka 客户端向 Eureka Server 注册时，提供元数据：ip地址、端口等
- 服务续约 Renew：Eureka 客户会每隔30秒(默认情况下)发送一次心跳来续约（注册表中）
- 获取注册列表信息 Fetch Registries：客户端用得到的注册信息表*获取其他服务，从而远程调用*
- 服务剔除：当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除



2. springboot 的负载均衡`Ribbon`

**RestTemplate是Spring提供的一个访问Http服务的客户端类**

Ribbon 是运行在消费者端的负载均衡器:
Consumer 端获取到了所有的服务列表之后，在其内部使用负载均衡算法，进行对多个系统的调用。

> 负载均衡选型： Nginx 和 Ribbon 的对比
> nginx: 将所有请求都集中起来，然后再进行负载均衡。而ribbon是在消费者端进行负载均衡的。 request位置不同。在 Nginx 中请求是先进入负载均衡器，而在 Ribbon 中是先在客户端进行负载均衡才进行请求的。

> 其次，负载均衡算法不同：nginx: 轮询和加权轮询。而ribbon是默认是使用的 RoundRobinRule 轮询策略： 若经过一轮轮询没有找到可用的 provider，其最多轮询 10 轮。若最终还没有找到，则返回 null。


3. 熔断降级用的Hystrix

作用：熔断、降级

熔断：当指定时间窗内的请求失败率达到设定阈值时，系统将通过 断路器 直接将此请求链路断开。
- 解决办法：设置超时时间

降级：执行后备处理：一个方法调用异常时，通过执行另一种代码逻辑
```java
// 指定了后备方法调用
@HystrixCommand(fallbackMethod = "getHystrixNews")
@GetMapping("/get/news")
public News getNews(@PathVariable("id") int id) {
    // 调用新闻系统的获取新闻api 代码逻辑省略
}
// 
public News getHystrixNews(@PathVariable("id") int id) {
    // 做服务降级
    // 返回当前人数太多，请稍后查看
}
```

4. 网关Zuul

网关：鉴权、限流、 路由、监控等功能。

zuul：网关和过滤器

    zuul的功能：
        - 路由映射，统一前缀
        - 过滤：从而实现 限流，灰度发布，权限控制


5. openFeign

为了方便服务间方法的调用：

之前的方法：

    每次都需要url、请求、返回类型 `return restTemplate.postForObject(url, request, Boolean.class);`

修改之后的方法：
    
    新建一个interface，用FeighClient实现方法的映射：
```java
@FeignClient(value = "eureka-client-provider")
public interface TestClient {
    // 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了
    @RequestMapping(value = "/provider/xxx",
    method = RequestMethod.POST)
    CommonResponse<List<Plan>> getPlans(@RequestBody planGetRequest request);
}
```
then, 在 Controller 就可以像原来调用 Service 层代码一样调用它了

## 2 docker

#### 容器和镜像：

Docker镜像是Docker容器的源代码。用于创建容器。使用build命令创建镜像。存储在docker注册表中。

Docker容器包括应用程序及其所有依赖项，但与其他容器共享内核

#### docker底层

Docker的工作原理：每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。

#### docker部署的本质是什么，

>1 运行环境的隔离：使用linux下的namespace。

PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。namespace之间都是透明的。用户层面上只能看到属于用户自己namespace下的资源，因此*ps*命令只能列出自己namespace下的进程.

>2 隔离地使用系统资源，比如网络、磁盘、CPU以及内存：Linux cgroups

以一组进程为目标进行系统资源分配和控制

    功能：隔离一个进程的集合，绑定cpu的核。或者限制他们使用的资源，比如内存使用上限以及文件系统的缓存限制，或者只能访问哪些设备。

    优先级控制，比如：CPU利用和磁盘IO吞吐。

    计费

    挂起进程，恢复执行进程

#### docker最大的优势

1. 官方优点：简化配置。将环境和配置放到代码里。

2. 端到端的发布：轻松从开发者机器发布到生产环境机器。

3. 合并服务资源。可以合并多个服务资源，每个容器使用与所有其他容器完全相同的内核。降低费用。

4. 可以更好的模拟分布式部署的环境。我们可以让多个docker装载一系列服务在单机上运行。可以模拟跨越网络连接等，让在单机上模拟分布式部署的环境。

5. 应用隔离。将原来的单体应用切分成很多微服务。将多个应用服务部署在多个Docker中，来实现应用之间的结偶。

6. 快速部署。比虚拟机启动速度快


#### docker是什么
容器化平台，将程序和所有依赖项打包在一起。为了让它在任何环境中无缝运行。包括代码、运行时环境、系统工具、系统库和设置

#### 如何使用Docker构建与环境无关的系统？

Volumes
环境变量注入
只读文件系统

docker包括

#### 和虚拟机的区别

##### 虚拟机：

    1. 基础设施、
    2. 虚拟机管理系统（为了在主操作系统之上运行多个不同的从操作系统）、
    3. 客户机操作系统、（虚拟机管理系统会启动多个客户机操作系统，来分别管理不同的互相隔离的应用
    4. 各种依赖（每一个客户机操作系统都需要安装许多依赖）
    5. 应用

##### Docker：

*（优点：没有臃肿的从操作系统）*

    1 基础设施
    2. 主操作系统
    3. Docker守护进程:（取代了虚拟机管理系统）运行在操作系统之上的后台进程，负责管理Docker容器. 可以直接与主操作系统通信。来为docker容器分配资源。还可以将容器与主操作系统隔离
    4. 各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的
    应用



    


