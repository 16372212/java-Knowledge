# 精髓
用数学的方法

# 题目
1915. 最美字符串
560. 和为 K 的子数组
930. 和相同的二元子数组
974. 和可被 K 整除的子数组
1371. 每个元音包含偶数次的最长子字符串
1542. 找出最长的超赞子字符串
1590. 使数组和能被 P 整除


1248
454


前缀和：只要是连续的数组，都可以使用前缀和的方式，来减少一个维度的便利（使连续）
560
前缀和的根本原因：由于需要求的是任意 sum（i，j）的和，如果便利i, j则复杂度为平方。
因此考虑使用和的方式： s(i,j）= total(j) - total(i), 而正好可以使用一个hash来保存所有的total(i) 的个数，这样就可以使
表达式连续起来了，不用考虑是否相邻。

### 方法：
需要找到：
s(i,j）= total(j) - total(i)
要求：s(i,j)满足 = k, 已知道total(i)的个数，以及s(i,j) = k, 则只用知道j与i的组合关系即可。，j与i没有关系，只要满足i比j小

```
// 便利所有的j:
for(int j = 0;j<n;j++){
    ans += hash[total(j) - k] // total(i)的个数
    hash[total(j)] ++;
}
```
# 1 用二维数组记录和：长方形内的个数：
or 可以包括的矩阵的个数
![7ce656dcd2669b4347b4a8735c8367c3.png](evernotecid://A85511B8-539E-4937-827C-EC06CD836516/appyinxiangcom/19533845/ENResource/p170)

*递推公式*：s(i,j) num of matrixs from 0,0 to i,j
所以矩阵个数: s(i,j) - s(i-x, j) - s(i,j-y) + s(i-x, j-y)  

# 2 用一个hash记录和：和为K的子数组

*递推公式*：k = s(i,j) = total(j) - total(i);
i<j
因为i一定< j, i, j不相关，所以只用遍历j, 而i不需要：用hash存储i出现的个数即可：key:total(i), value: 出现的次数

因此：可以先写出来i,j的递推公式，然后利用hash进行优化

# 3 差分记录
这里有 n 个航班，它们分别从 1 到 n 进行编号。

有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。

请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。

> 2-5之间都需要加10，则只需要让上一个值依赖于后一个值的增加或减少即可。vec[2] = 10, vec[6] = 10

