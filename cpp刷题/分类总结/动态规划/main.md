# 判断方法

### 暴力能否转换成动态规划：
判断是否是 无后效性的： 递归状态的返回值与怎么到达这个状态的路径无关，（面试一般多是）

### 做题步骤
> 尝试的方法：
> 1. 方程的思想：尽量用数组来表示结果
> 2. 举例子，来实现数组操作更新的某一步：从i到i+1
> 3. 写出相应暴力的方法
> 4. 画图，把暴力化成动态规划（使用代码的角度更容易查看如何化解）

### 暴力转动规的规范化步骤：
1. 找到参数：哪些参数定下来，返回值就确定了
2. 把可变参数的所有组合变成一张表，1个参数是1维，两个是2维
3. 表中标出最终答案，base case
4. 填表
5. 填好之后就知道怎么写了

#### 如果不想填表
可以根据公式的增长方式来转化：例如（i, j）依赖于（i+1, j-1）因此就知道，i从n到0遍历，j从0到n遍历。

# 1 分割类问题
**（不依赖相邻，依赖上一次分割的值）**

分个类问题是 *不依赖相邻的*（一个数字分割成最少个数的平方数之和）

### 完全平方数分割问题

>题目：
>已知d[i]为当前待求，d[0-i-1]都知道值，

`d[i] = min(d[i-k^2])+1; `
（因为是平方数，所以只需要便利k即可）

handle

### 字符串

> 题目：
> 给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到.
>"appleinapple" -> ["apple", "app", "in"]

`d[i] = d[i] || d[i-len(word)] // word每次循环所有的值`


# 2 子序列问题
### 2.1 最长递增子序列(300)

#### 方法1
d[i]第i个结尾的最长个数
`d[i] = max(d[i-k]) + 1`
#### 方法2(*****)

d[i]: len为i的子序列的最后一个字母
每次更新d[k]（找到这样的k）为`nums[i] :nums[k-1] <= nums[i] < nums[k]`

### 2.2 丑数

小顶堆的方法是先存再排，dp的方法则是先排再存
其中动态规划的方法：

    point2: 存放用来乘2的数字的index
    point3: 存放乘3的数字的index
    这样每次都选择最小的往里放。（有点类似多个有序链表合并，谁放了谁往后链接一个）

### 2.3 股票问题简单版：

计算最大子序和

    d[i]: 按照i结尾的数组的最大和（从哪个开始计算不考虑）
    d[i+1] = max{ d[i]+num[i+1], num[i]} 判断是否应该摒弃前面所有从头开始，还是干脆加入。因为前面是无状态的。
    

# 3 背包问题 & others

### 3.1 零钱兑换

可以组成相应amount的最少的零钱个数

coins = [1, 2, 5], amount = 11
`dp[i] = min(dp[i-l)+1, dp[i])`

### 3.2 零钱兑换2 换钱的方法数

>题目：
>输入：amount = 5, coins = [1, 2, 5]
    输出：4
    解释：有四种方式可以凑成总金额：
    5=5
    5=2+2+1
    5=2+1+1+1
    5=1+1+1+1+1

1. 动态规划1
通过分析，每个节点要不要和最终的数据，发现和两个变量有关：index, aim

    `d[i][aim] += d[i-1][aim - k*coins[i] ]` // 使用货币0-i, 组成aim的方法数

分析递归函数的状态由哪些变量表示，然后做出相应map


2. 动态规划2
`d[i][aim] += d[i-1][aim - k*coins[i] ]// 使用货币0-i, 组成aim的方法数`
以上的循环可以简写成
`d[i][aim] = d[i-1][aim] + d[i][aim - coins[i] ]`

(并且循环不好写！！！）

### 3.3 打气球的最大分数

> 题目描述
给定一个数组arr,长度为n。代表排有分数的气球。 每打爆一个气球都能获得分数，假设打爆气球的分数为X，获得分数的规则如下:
1)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为L:如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为R.获得分数为LXR
2)如果被打爆的气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为L:如果被打爆气球的右边所有气球都已经被打爆，获得分数为LX。
3)如果被打爆气球的左边所有的气球都已经被打爆:如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球。获得分数为XR.
4)如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为X。
目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。



步骤1. dp[r][l]: 从r到l的气球分数的最大值
步骤2. 举例子：
```c++
    // 如果最后一个打爆r, 则：。。。
    // 如果最后一个打爆r-1, 则：。。。
    
    // 如果最后一个打爆i，且r<i<l，则
    dp[r][l] = dp[r][i-1] + dp[i+1][l] + num[r-1] * num[i]* num[l+1];
```
这时，如果让数组两端都增加1，则会发现，可避免边缘情况。

步骤3.写出相应暴力方法：（已写出
步骤4. 暴力转动态规划

   根据公式的增长方式来转化：例如（i, j）依赖于（i+1, j-1）因此就知道，i从n到0遍历，j从0到n遍历。
   
   ### 3.4 打气球的最大分数
   机器人到达指定位置方法数
   
   
   > 题目：
   > 假设有排成一行的N个位置，记为1~N，开始时机器人在M位置，机器人可以往左或者往右走，如果机器人在1位置，那么下一步机器人只能走到2位置，如果机器人在N位置，那么下一步机器人只能走到N-1位置。规定机器人只能走k步，最终能来到P位置的方法有多少种。由于方案数可能比较大，所以答案需要对1e9+7取模。

步骤1. dp[pos][step]: 当前在位置pos, 处于第step步
步骤2. 举例子：好像可以直接略过
步骤3：dp[pos] = dp[pos-1][step-1] + dp[pos+1][step-1] 


### 3.5 换钱的方法数

> 题目：
> 给定数组arr, arr中所有的值都是正数，且不重复。每个值的货币可以用任意张。再给定一个整数aim, 代表要找的钱数。求换钱有多少种方法。


步骤1. d[k] 得到k元的方式由多少种
步骤2：略
步骤3：暴力的方法：k从1-n迭代：d[k] += d[k-num[i]];  （k-num[i] > 0）
步骤4：转动规，没必要了

### 3.5 学生出勤记录 II
> 题目
> 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
按总出勤 计，学生缺勤（'A'）严格 少于两天。
学生不会存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。


这个题，部分无后效性。某段长度的方法个数，不决定后一段长度的方法个数（只有在连接处会依赖。以及A的个数会进行限制）

因此考虑可以设置
```c++
d[n][i][j] : n长度的数组中，i个A, 这段数组的结束部分L的个数
```

尝试后（尝试过程略）
发现可以有d[n][i][j]与d[n-1][][]的递推方法

直接拿过来d[n][][]就递推d[n-1][][]容易少算，所以应该结合题意，对分析当前决策状态：

- 当这前最后一个放A: d[n][1][1] = d[n-1][0][0-2]
- 当这前最后一个放L: d[n][0-1][1-2] += d[n-1][0-1][0-1]
- 当这前最后一个放P: d[n][0-1][0] += d[n-1][0-1][0-2]


是有重叠的。写出递推循环即可。

### 3.6 暴力枚举集合

1. 一般需要枚举所有集合, 且是暴力的方法，则范围会很小，不能超过20。

> 状态压缩：状态压缩，其实就是将每个任务 task[i] 看作某个 「 十进制数字 」 的二进制上的第 i 位，1 表示该任务被选择，反之不被选择。

**用二进制表示集合**，对于集合的子集，可以用(i|j)=j，则i是j的子集

这样，对于所有种集合的组成情况，可以用二进制方法方便遍历：一共有1<<k种。k=元素个数


```java
// 枚举所有子集
for(int i =0;i<m;i++){
    // 例如i:11001，意思第一个，二个，5个组成的集合
    int state = i;
    while(state > 0){
        int element = state&1;
        state >>= 1;
    }
}

// 枚举每个集合的所有子集
// 方法1
for (int i = 1; i < m; i++) {
    // 枚举状态 i 的二进制子集
    for (int j = i; j > 0; j = (j - 1) & i) {
        // To Do..
    }
}

// 方法2
for (int i = 1; i < m; i++) {
    // 从 [1, i] 就可以了，后面的一定不会是 i 的子集
    for (int j = 1; j <= i; j++) {
        // 检查状态 j 是不是状态 i 的二进制子集
        if ((i | j) == i) {
            // To Do...
        }
    }
}
```