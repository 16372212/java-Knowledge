# 栈

## 1. 无规律
## 2. 单调栈问题

### 2.1 84 直方图最大矩阵
            
        使用暴力解法，i,j。判断i, j之间的面积（暴力的话，宽度确定）
        
   确定是否是**完全单调**：发现相等的情况，也必须pop，因为第二次是从右往左筛查，需要得到下一个比他小的节点的index.因此左侧不能够出现和他长度相等的节点。
   
   需要重视的点：
   1. 判断是否为完全单调，碰到相等的，是保留最左端的还是最右端的。
   2. 因为保留的事最右端的，因此通过top的上一个矩阵的index值获得矩阵width，因此矩阵的width需要先pop。而宽度就是本身的top（pop之前的）。
   3. 容易出问题的点：判断非空。中间也有pop, 容易控指针。因此可以实现push一个-1；
   4. 记录判断宽度的方向：遍历中是向左获得width，因为保留的是 相同高度下最右端的矩阵，并且右边的情况如何未判断so并不知晓。而遍历之后，是向右判断获得长度。因为保留在stack中，说明右面不会再有比当前矩阵高的矩阵。因此用（heights.size() - 上一个矩阵的index值-1）代表width
   
        
        分治法：每次找到最小的数据，然后根据最小的index将整个分成左边和右边进行寻找
    
### 2.2 类似的题：接雨水
        
        1 动态规划：对每个点，得到左边的最大值和右边的最大值，进行计算。创建两个长度为 nn 的数组 \textit{leftMax}leftMax 和 \textit{rightMax}rightMax。对于 0 \le i<n0≤i<n，\textit{leftMax}[i]leftMax[i] 表示下标 ii 及其左边的位置中，\textit{height}height 的最大高度
        
        2 单调栈：存储一个小顶栈。判断栈顶元素，次栈顶元素于当前元素的关系
        
    （二分法总是不熟练：遍历时，尽量取[left, right)的区间。终止标准：left==right, left==right-1)
    
    同时，这两个方法都可以使用单调栈解决。

### 2.3 矩阵中最大的矩形面积

改良版本的“直方图中”

分割成多个列的直方图。发现直方图的写法还不太熟练。需要掌握的重点。


### 3 单调栈问题总结

单调栈总结：
1【解决的问题】
比当前元素更大的下一个元素
比当前元素更大的前一个元素
比当前元素更小的下一个元素
比当前元素更小的前一个元素

2. 总结博客 https://blog.csdn.net/qq_17550379/article/details/86519771

3. 注意事项：

        1. 判断是否是严格单调栈还是非严格单调栈（根据题意确定我们栈中是否可以存放相同元素）
        2. 如果严格，那么保留最左端的还是最右端的
        3. 判断矩阵的width时，考虑向右找还是向左找，并且是否需要借助top的上一个矩阵的index得到。（考虑向左向右的技巧：如果保留最右端的，那么遍历时，右侧情况未知，因此应高向左找得到width。
        4. 对于empty的判断，中间存在pop就需要判空，有可能存在空指针，因此可以提前push一个-1.

# 4. 递归

因为递归的本质是栈。

## 4.1 斐波那契

f(n) = f(n-1) + f(n-2)

> 这种情况不能直接 getAns(n-1) + getAns(n-2). 会有大量的重复计算，需要先保存好计算结果。所以应该写一个循环，从小往大。

青蛙跳台阶等都是斐波那契，一定记得要优化。

