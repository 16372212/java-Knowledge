# 知识点

## 范式
1NF：符合原子特性，不可再分。这个字段只能是一个值，不能再分为多个其他的字段了

2NF：消除非候选集对码的部分函数依赖（比如姓名依赖于学号，姓名依赖于身份证号，则姓名部分依赖于（学号、身份证号），y中存在一个真子集，x依赖于y的这个真子集，则x依赖于y）

    消除方法：消除复合主键，增加单列关键字。

3NF：消除非候选集对码的传递函数依赖（系主任依赖于系名，系名依赖于学号，则系主任传递依赖于学号）

    消除方法：将一个实体的信息放到一个表内实现。（拆分）

事物是什么：逻辑上一组操作

## 关键字

- GROUP BY

- HAVING: where相同，但是where是在开始执行时检测数据，对原始数据进行过滤。having是对筛选出来的结果再次进行过滤。

    where是数据表中存在的，having是针对查询出来的。
    sql标准要求，having必须引用GROUP BY中的列或用于合计函数中的列。

## 事物的ACID

事物的ACID怎么保证：

原子性：不能只执行一部分，要么全做完，要么就都不做： undo log来回滚。
一致性：执行食物前后，数据保持一致，比如汇款前后，总额不变。
隔离性：并发的事物之间是隔离的。（加锁）
持久性：redo log。数据库发生故障，也不应该让一个事物的改动失效。


## 引擎

MyISAM: 不支持*事物*和*行级锁*。崩溃后无法安全修复。不支持*外键*

innoDB：提供事物支持，可以提交和回滚。默认都是行级锁。支持*外键*

## 并发的问题

- 脏读： 一个事物对数据进行修改没提交，这个数据就被另一个事物使用了。

- 幻读：一个事物对数据进行读取时，另一个事物添加了几行数据，在第一个事物的后续操作中发现多了好多不存在的数据。

- 不可重复读： 一个事物对数据进行读取，第二个事物对这个数据进行了修改，导致第一个数据第二次读的数据和之前不一样。

## 事物的隔离级别

- 读未提交：允许读取没提交的事物
- 读已提交：
- 可重复读（innoDB默认级别）：对一个数据的多次读取结果都是一样的，除非被自己修改
- 可串行化：所有事物依次执行

## 索引

对于MyISAM和InnoDB这两种索引的实现策略：

### 1. MyISAM

索引和数据分离。

叶子节点的data部分，存放数据的地址。所以每次查找，按照B+树找到data域的值，按照这个值作为地址，来取数据

优点：更新代价小，

缺点： 依赖于有序数据。需要二次查询（回表）

### 2. innoDB

聚集索引：innoDB叶子结点的数据文件本身就是索引结构。将数据和索引放到一起存储

#### 主索引和辅助索引：

> 建表的时候，会自动根据主键构建一颗主索引树，叶子结点的key存储的是主键key，data存储的是对应的数据。

> 而构建其他索引的时候，会相应建立辅助索引树。叶子结点的key是索引key，data部分存储的是主键key。这样根据辅助索引搜索需要先找到主键，再在主索引树中找到相应的data的值。

InnoDB 需要节省存储空间. 一个表中可能有多个索引，因此会存储多个索引树。

优点：速度快，叶子结点是有序的。

缺点：依赖于有序的数据，不然插入太慢。更新代价大，因为索引多。


#### 索引覆盖

要查的值正好是索引的字段。

#### 添加索引的方法

```sql
ALTER TABLE `table_name` ADD [PRIMARY KEY/ UNIQUE/ INDEX index_name/ FULLTEXT] （`column`）
```


# mysql面试题

1：MySQL 的逻辑架构了解吗？

    第一层：客户端。图形化界面和接口之类的
    二：service层。查询解析、分析、优化、缓存以及内置函数
    三：innodb存储引擎。负责数据存储和读取


2：谈一谈 MySQL 的读写锁

    读：共享锁：都能访问到数据，但是只能读不能修改。`select ... lock in share mode`

    写：排他锁。update,delete,insert 都涉及 `select ... for update`

3：MySQL 的锁策略有什么？

    首先回答不同引擎对应的是什么锁（表级和行级）
    
> MyISAM: 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁。不会出现死锁。

> MyISAM的调度：如果有读写请求同时进行的话，MYSQL将会优先执行写操作。因此可能造成查询阻塞。

----------------

> innoDB: 行锁。行锁不影响读操作,只影响写操作。select不加锁，update, delete, insert自动给涉及到的数据加写锁。

> 行锁的实现方式：行锁是通过给索引上的索引项加锁来实现的



4：数据库死锁的情况以及如何解决？
    
    当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就会出现死锁

    现象1. 事务之间对资源访问顺序的交替。解决方法： 调整程序的逻辑

    现象2. 共同修改同一记录。（用户A查询data后想修改data, 用户B此时想修改data。A对data的锁从查询的共享锁想上升到排他锁，B对A的锁是排他锁。但此时，B要等A释放共享锁，A由于B的排他锁，没办法释放共享锁）解决办法：统一使用乐观锁。或者统一使用悲观锁。

    避免死锁的办法：

    1. 尽量按某种顺序访问表和行，按顺序申请锁
    2. 大事物拆成小事物
    3. 一个事物里尽量做到 一次性锁定所有资源
    4. 降低隔离级别
    5. 为表添加合理的索引。如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。
    

5：事务是什么?

    逻辑上的一组操作。

6：事务有什么特性？

    ACID, 原子，一致，隔离，持久

7：MySQL 的隔离级别有哪些？

    未提交读
    提交读
    可重复读
    可串行化

8：MVCC 是什么？

    多版本控制

9：谈一谈 InnoDB

    支持：事物、行锁、外键。
    行锁的执行方式：select不加锁，delete等加锁。实现方式是给索引上的索引项加锁来实现。
    索引：数据文件本身就是索引文件。可以分成主索引和辅助索引...

10：谈一谈 MyISAM

    不支持：
    锁：select for lock share mode执行读锁，修改执行select for update
    索引：索引和数据分离。叶子节点的data存放数据的地址

11：谈一谈 Memory

12：查询执行流程是什么？

    1. 客户端发送查询给服务器。

    2. 服务器检查缓存，没有命中则进入下一阶段
    
    3. 服务端sql词法、语法分析（生成解析树、验证是否有错误关键字、顺序是否正确等）、预处理（根据mysql规则进一步检查解析树是否合法。比如数据是否存在。然后根据检查用户是否有该处理权限）、优化器生成对应执行计划

    4. mysql根据优化器生成的执行计划，调用存储引擎API来执行查询

    5. 返回结果

13：VARCHAR 和 CHAR 的区别？

    char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足

    varchar(M)每个值只占用刚好够用的字节再加上一个用来记录其长度的字节

14：DATETIME 和 TIMESTAMP 的区别？

    timestamp会跟随设置的时区变化而变化，而datetime保存的是绝对值不会变化

    timestamp可以自动更新：可以设置timestamp列自动以当前时间(CURRENT_TIMESTAMP)填充/更新

15：数据类型有哪些优化策略？

16：索引有什么作用？

17：谈一谈 MySQL 的 B-Tree 索引

    Mysql索引使用的数据结构主要有BTree（B+）索引（其他情况可以使用） 和 哈希索引（单条记录时可以使用）


18：了解 Hash 索引吗？

19：什么是自适应哈希索引？

20 ：什么是空间索引？

21：什么是全文索引？

22：什么是聚簇索引？

23：什么是覆盖索引？

24：你知道哪些索引使用原则？

25：索引失效的情况有哪些？

26：如何定位低效 SQL？

27：SHOW PROFILE 的作用？

28：trace 是干什么的？

29：EXPLAIN 的字段有哪些，具有什么含义？

30：有哪些优化 SQL 的策略？

31：MySQL 主从复制的作用？

32: 悲观锁和乐观锁

>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。实现方式：依靠数据库的锁机制for update

>乐观锁：本身是不加锁的。只是在更新的时候判断其他线程是否更新了这个数据。
    
    假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。
    
    乐观锁如何检查是否违反数据完整性：通过版本号或时间戳来表示。

    

